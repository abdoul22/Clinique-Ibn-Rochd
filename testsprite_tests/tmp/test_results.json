[
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "9f2b2043-8600-4d25-9b2c-be48d614f1ed",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC001-verify_caisse_api_numero_entree_medecin",
    "description": "Test the API endpoint /api/caisses/numero-entree/{medecin_id} to verify it returns the correct next entry number for a specific doctor's financial transactions.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\ndef verify_caisse_api_numero_entree_medecin():\n    base_url = \"http://localhost:8000\"\n    numero_entree_endpoint_template = f\"{base_url}/api/caisses/numero-entree/{{medecin_id}}\"\n    auth = HTTPBasicAuth(\"abdoullah@gmail.com\", \"12345678\")\n    timeout = 30\n\n    medecin_id = 1  # Use a fixed medecin_id for the test\n\n    try:\n        # Call the numero-entree endpoint for the medecin_id\n        numero_entree_endpoint = numero_entree_endpoint_template.format(medecin_id=medecin_id)\n        response = requests.get(numero_entree_endpoint, auth=auth, timeout=timeout)\n        response.raise_for_status()\n\n        data = response.json()\n        # Validate response is a dict with 'next_numero_entree' integer field\n        assert isinstance(data, dict), \"Response should be a JSON object\"\n        next_numero_entree = data.get(\"next_numero_entree\")\n        assert next_numero_entree is not None, \"Response missing 'next_numero_entree'\"\n        assert isinstance(next_numero_entree, int), \"'next_numero_entree' should be an integer\"\n        assert next_numero_entree >= 0, \"'next_numero_entree' should be non-negative\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\nverify_caisse_api_numero_entree_medecin()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 29, in <module>\n  File \"<string>\", line 20, in verify_caisse_api_numero_entree_medecin\nAssertionError: Response should be a JSON object\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.450Z",
    "modified": "2025-12-02T12:45:43.205Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "ab7bad66-1566-4125-b105-3064901b9a6b",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC002-verify_caisse_transaction_creation",
    "description": "Test creating a caisse transaction (facture) and verify that it correctly calculates total, creates EtatCaisse with recette, part_medecin, and part_clinique.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = ('abdoullah@gmail.com', '12345678')\nTIMEOUT = 30\nHEADERS = {'Content-Type': 'application/json'}\n\n\ndef verify_caisse_transaction_creation():\n    # Step 1: Fetch existing ModePaiements to get an id\n    mode_paiement_id = None\n    try:\n        res_mode_list = requests.get(\n            f\"{BASE_URL}/api/modepaiements\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert res_mode_list.status_code == 200, f\"Failed to fetch ModePaiements: {res_mode_list.text}\"\n        mode_paiements = res_mode_list.json()\n        assert isinstance(mode_paiements, list) and len(mode_paiements) > 0, \"No ModePaiements found for test\"\n        mode_paiement_id = mode_paiements[0].get(\"id\")\n        assert mode_paiement_id is not None, \"ModePaiement id missing in first entry\"\n\n        # Step 2: Prepare data for creating a caisse transaction (facture)\n        res_examens = requests.get(\n            f\"{BASE_URL}/api/examens\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert res_examens.status_code == 200, f\"Failed fetching examens: {res_examens.text}\"\n        examens_list = res_examens.json()\n        assert isinstance(examens_list, list) and len(examens_list) > 0, \"No examens found for test\"\n\n        examen = examens_list[0]\n        examen_id = examen.get(\"id\")\n        part_medecin = examen.get(\"part_medecin\")\n        part_clinique = examen.get(\"part_cabinet\") or examen.get(\"part_clinique\") or 0\n        prix = examen.get(\"prix\") or 100  # fallback price\n\n        examens_data = [\n            {\n                \"examen_id\": examen_id,\n                \"quantite\": 2,\n                \"prix\": prix,\n                \"part_medecin\": part_medecin,\n                \"part_clinique\": part_clinique,\n            }\n        ]\n        total_expected = prix * 2\n        part_medecin_expected = part_medecin * 2\n        part_clinique_expected = part_clinique * 2\n\n        # Step 3: Create caisse transaction (facture)\n        caisse_payload = {\n            \"date\": \"2025-06-15\",\n            \"mode_paiement_id\": mode_paiement_id,\n            \"examens\": examens_data,\n            \"remise\": 0,\n            \"description\": \"Facture test creation\",\n            # Omit patient_id and medecin_id if None or not needed\n        }\n\n        res_caisse = requests.post(\n            f\"{BASE_URL}/api/caisses\",\n            json=caisse_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert res_caisse.status_code == 201, f\"Failed to create caisse: {res_caisse.text}\"\n        caisse = res_caisse.json()\n        caisse_id = caisse.get(\"id\")\n        assert caisse_id is not None, \"Caisse id missing in response\"\n\n        total_returned = caisse.get(\"total\")\n        part_medecin_returned = caisse.get(\"part_medecin\")\n        part_clinique_returned = caisse.get(\"part_clinique\")\n\n        assert total_returned == total_expected, f\"Total mismatch: expected {total_expected}, got {total_returned}\"\n        assert part_medecin_returned == part_medecin_expected, f\"part_medecin mismatch: expected {part_medecin_expected}, got {part_medecin_returned}\"\n        assert part_clinique_returned == part_clinique_expected, f\"part_clinique mismatch: expected {part_clinique_expected}, got {part_clinique_returned}\"\n\n        res_etat = requests.get(\n            f\"{BASE_URL}/etatcaisse?caisse_id={caisse_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        if res_etat.status_code != 200:\n            res_etat_all = requests.get(\n                f\"{BASE_URL}/etatcaisse\",\n                auth=AUTH,\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n            assert res_etat_all.status_code == 200, f\"Failed to fetch EtatCaisse: {res_etat_all.text}\"\n            etats = [etat for etat in res_etat_all.json() if etat.get(\"caisse_id\") == caisse_id]\n            assert len(etats) > 0, \"No EtatCaisse entry found for created caisse\"\n            etat_caisse = etats[0]\n        else:\n            etats = res_etat.json()\n            if isinstance(etats, list):\n                assert len(etats) > 0, \"No EtatCaisse entry found for created caisse\"\n                etat_caisse = etats[0]\n            else:\n                etat_caisse = etats\n\n        recette = etat_caisse.get(\"recette\")\n        assert recette == total_expected, f\"Recette mismatch in EtatCaisse: expected {total_expected}, got {recette}\"\n\n        etat_part_medecin = etat_caisse.get(\"part_medecin\")\n        etat_part_clinique = etat_caisse.get(\"part_clinique\")\n\n        assert etat_part_medecin == part_medecin_expected, f\"EtatCaisse part_medecin mismatch: expected {part_medecin_expected}, got {etat_part_medecin}\"\n        assert etat_part_clinique == part_clinique_expected, f\"EtatCaisse part_clinique mismatch: expected {part_clinique_expected}, got {etat_part_clinique}\"\n\n    finally:\n        if 'caisse' in locals() and caisse and 'id' in caisse:\n            requests.delete(\n                f\"{BASE_URL}/api/caisses/{caisse['id']}\",\n                auth=AUTH,\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n\n\noverify_caisse_transaction_creation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 129, in <module>\nNameError: name 'overify_caisse_transaction_creation' is not defined. Did you mean: 'verify_caisse_transaction_creation'?\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.461Z",
    "modified": "2025-12-02T12:46:26.642Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "eb9e97c3-c481-4c80-abde-960cfe00a03d",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC003-verify_caisse_doctor_share_calculation",
    "description": "Test that part_medecin is correctly calculated from examen.part_medecin multiplied by quantity when creating a caisse transaction.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nAUTH = (\"abdoullah@gmail.com\", \"12345678\")\n\ndef test_verify_caisse_doctor_share_calculation():\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    # Step 1: Create an examen with a known part_medecin value\n    examen_payload = {\n        \"libelle\": \"Examen test part_medecin\",\n        \"prix\": 1000,\n        \"part_medecin\": 150,  # physician share per unit\n        \"part_cabinet\": 850,\n        \"unite\": \"examen\",\n        \"description\": \"Test examen for part_medecin calculation\",\n        \"categorie\": \"Radiologie\"\n    }\n    examen = None\n    caisse = None\n    try:\n        r = requests.post(\n            f\"{BASE_URL}/api/examens\",\n            json=examen_payload,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT,\n        )\n        r.raise_for_status()\n        examen = r.json()\n        examen_id = examen.get(\"id\")\n        assert examen_id is not None\n\n        quantity = 3  # quantity for the caisse transaction\n\n        # Step 2: Create a caisse transaction with one examen line with quantity\n        caisse_payload = {\n            \"medecin_id\": 1,  # We use a doctor ID 1 (assuming exists)\n            \"numero_entree\": None,\n            \"total\": examen_payload[\"prix\"] * quantity,\n            \"examens\": [\n                {\n                    \"examen_id\": examen_id,\n                    \"quantity\": quantity,\n                    \"prix\": examen_payload[\"prix\"],\n                }\n            ],\n            \"part_medecin\": examen_payload[\"part_medecin\"] * quantity,\n            \"part_cabinet\": examen_payload[\"part_cabinet\"] * quantity,\n            \"patient_id\": None,\n            \"mode_paiement_id\": None,\n            \"assurance_id\": None\n        }\n\n        r2 = requests.post(\n            f\"{BASE_URL}/api/caisses\",\n            json=caisse_payload,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT,\n        )\n        r2.raise_for_status()\n        caisse = r2.json()\n        caisse_id = caisse.get(\"id\")\n        assert caisse_id is not None\n\n        # Validate part_medecin correctness in the response\n        returned_part_medecin = caisse.get(\"part_medecin\")\n        expected_part_medecin = examen_payload[\"part_medecin\"] * quantity\n\n        assert returned_part_medecin == expected_part_medecin, \\\n            f\"Expected part_medecin {expected_part_medecin}, got {returned_part_medecin}\"\n\n    finally:\n        # Cleanup: delete created caisse and examen if they exist\n        if caisse and \"id\" in caisse:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/caisses/{caisse['id']}\",\n                    auth=AUTH,\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\n        if examen and \"id\" in examen:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/examens/{examen['id']}\",\n                    auth=AUTH,\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\ntest_verify_caisse_doctor_share_calculation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 100, in <module>\n  File \"<string>\", line 33, in test_verify_caisse_doctor_share_calculation\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/api/examens\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.468Z",
    "modified": "2025-12-02T12:45:38.407Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "3d7af8c3-6cc3-4c46-9824-06650e8fa5fc",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC004-verify_caisse_clinic_share_calculation",
    "description": "Test that part_clinique (part_cabinet) is correctly calculated from examen.part_cabinet multiplied by quantity when creating a caisse transaction.",
    "code": "import requests\nimport sys\n\nBASE_URL = \"http://localhost:8000\"\nAUTH_USERNAME = \"abdoullah@gmail.com\"\nAUTH_PASSWORD = \"12345678\"\nTIMEOUT = 30\n\nauth_headers = {\n    \"Authorization\": requests.auth._basic_auth_str(AUTH_USERNAME, AUTH_PASSWORD),\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_verify_caisse_clinic_share_calculation():\n    # Step 1: Create an Examen to use in the caisse transaction (assumed route /admin/examens POST)\n    examen_payload = {\n        \"nom\": \"Test Examen Part Cabinet\",\n        \"description\": \"Examen for testing part_cabinet calculation\",\n        \"prix\": 100.0,\n        \"part_medecin\": 30.0,\n        \"part_cabinet\": 70.0,\n        \"categorie\": \"Radiologie\"\n    }\n    examen_id = None\n    caisse_id = None\n    try:\n        examen_resp = requests.post(\n            f\"{BASE_URL}/admin/examens\",\n            json=examen_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert examen_resp.status_code == 201 or examen_resp.status_code == 200, f\"Failed to create examen: {examen_resp.text}\"\n        examen_created = examen_resp.json()\n        examen_id = examen_created.get(\"id\")\n        assert examen_id is not None, \"Examen ID not returned.\"\n\n        # Step 2: Create a caisse transaction using the examen with quantity and verifying part_clinique calculation\n        quantity = 3\n        caisse_payload = {\n            \"date_operation\": \"2025-11-19T10:00:00Z\",\n            \"mode_paiement_id\": 1,  # assumption: mode paiement with id 1 exists\n            \"examen_id\": examen_id,\n            \"quantite\": quantity,\n            \"patient_id\": 1,  # assumption: patient with id 1 exists\n            \"user_id\": 1,  # assumption: user with id 1 creating transaction\n            \"montant_paye\": 100.0 * quantity,\n            \"part_medecin\": 30.0 * quantity,\n            \"part_cabinet\": 70.0 * quantity,\n            # Other necessary fields assuming\n            \"total\": 100.0 * quantity\n        }\n\n        caisse_resp = requests.post(\n            f\"{BASE_URL}/admin/caisses\",\n            json=caisse_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert caisse_resp.status_code == 201 or caisse_resp.status_code == 200, f\"Failed to create caisse transaction: {caisse_resp.text}\"\n        caisse_created = caisse_resp.json()\n        caisse_id = caisse_created.get(\"id\")\n        assert caisse_id is not None, \"Caisse ID not returned.\"\n\n        # Step 3: Fetch the created caisse transaction to verify part_cabinet calculation\n        get_resp = requests.get(f\"{BASE_URL}/admin/caisses/{caisse_id}\", headers=auth_headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Failed to fetch caisse transaction: {get_resp.text}\"\n        caisse_data = get_resp.json()\n\n        expected_part_cabinet = 70.0 * quantity\n        actual_part_cabinet = caisse_data.get(\"part_cabinet\")\n        assert actual_part_cabinet == expected_part_cabinet, f\"part_cabinet calculation mismatch: expected {expected_part_cabinet}, got {actual_part_cabinet}\"\n\n    finally:\n        # Cleanup: delete created caisse transaction and examen if they were created\n        if caisse_id is not None:\n            try:\n                del_resp = requests.delete(f\"{BASE_URL}/admin/caisses/{caisse_id}\", headers=auth_headers, timeout=TIMEOUT)\n                if del_resp.status_code not in [200, 204]:\n                    print(f\"Warning: Failed to delete caisse {caisse_id}: {del_resp.status_code}\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error deleting caisse {caisse_id}: {e}\", file=sys.stderr)\n        if examen_id is not None:\n            try:\n                del_resp = requests.delete(f\"{BASE_URL}/admin/examens/{examen_id}\", headers=auth_headers, timeout=TIMEOUT)\n                if del_resp.status_code not in [200, 204]:\n                    print(f\"Warning: Failed to delete examen {examen_id}: {del_resp.status_code}\", file=sys.stderr)\n            except Exception as e:\n                print(f\"Error deleting examen {examen_id}: {e}\", file=sys.stderr)\n\ntest_verify_caisse_clinic_share_calculation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 92, in <module>\n  File \"<string>\", line 34, in test_verify_caisse_clinic_share_calculation\nAssertionError: Failed to create examen: {\"message\":\"Unauthenticated.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.474Z",
    "modified": "2025-12-02T12:46:08.521Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "25e05549-cf1e-4267-86c3-b9f92525e054",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC005-verify_caisse_insurance_coverage",
    "description": "Test that when a caisse transaction includes insurance (assurance_id), it correctly calculates recette as total minus insurance coverage percentage, and creates a Credit for the insurance company.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nHEADERS = {\n    \"Authorization\": \"Basic YWJkb3VsbGFoQGdtYWlsLmNvbToxMjM0NTY3OA==\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_verify_caisse_insurance_coverage():\n    # Step 1: Create a test insurance company (Assurance)\n    assurance_payload = {\n        \"nom\": \"Test Assurance\",\n        \"couverture\": 20  # 20% coverage\n    }\n    assurance_resp = requests.post(\n        f\"{BASE_URL}/assurances\",\n        json=assurance_payload,\n        headers=HEADERS,\n        timeout=TIMEOUT,\n    )\n    assert assurance_resp.status_code == 201\n    assurance = assurance_resp.json()\n    assurance_id = assurance.get(\"id\")\n    assert assurance_id is not None\n\n    # Step 2: Create a caisse transaction with a total and assurance_id\n    # We will create this caisse with total = 1000 and assurance coverage 20%\n    caisse_payload = {\n        \"date\": \"2025-11-19\",\n        \"total\": 1000,\n        \"assurance_id\": assurance_id,\n        \"description\": \"Test caisse transaction with insurance coverage\"\n    }\n\n    caisse_resp = requests.post(\n        f\"{BASE_URL}/caisses\",\n        json=caisse_payload,\n        headers=HEADERS,\n        timeout=TIMEOUT,\n    )\n    assert caisse_resp.status_code == 201\n    caisse = caisse_resp.json()\n    caisse_id = caisse.get(\"id\")\n    assert caisse_id is not None\n\n    try:\n        # Step 3: Get detailed caisse record to verify recette calculation\n        get_caisse_resp = requests.get(\n            f\"{BASE_URL}/caisses/{caisse_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert get_caisse_resp.status_code == 200\n        caisse_detail = get_caisse_resp.json()\n\n        total = float(caisse_detail.get(\"total\", 0))\n        recette = float(caisse_detail.get(\"recette\", -1))\n        couverture = float(assurance.get(\"couverture\", 0))\n\n        # recette should be total - (total * couverture / 100)\n        expected_recette = total - (total * couverture / 100)\n\n        assert abs(recette - expected_recette) < 0.01, (\n            f\"Expected recette {expected_recette}, got {recette}\")\n\n        # Step 4: Verify that a Credit was created for the insurance company\n        # We fetch credits filtered by assurance_id and caisse_id to find a matching credit\n        credits_resp = requests.get(\n            f\"{BASE_URL}/credits?assurance_id={assurance_id}&caisse_id={caisse_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert credits_resp.status_code == 200\n        credits = credits_resp.json()\n        assert isinstance(credits, list)\n        assert len(credits) > 0, \"No credit created for the insurance company.\"\n\n        # Check montant of credit equals total * couverture / 100\n        credit_match_found = False\n        expected_credit_montant = total * couverture / 100\n        for credit in credits:\n            montant = float(credit.get(\"montant\", -1))\n            # Accept small floating point tolerance\n            if abs(montant - expected_credit_montant) < 0.01:\n                credit_match_found = True\n                break\n        assert credit_match_found, \"Credit montant does not match insurance coverage calculation.\"\n\n    finally:\n        # Cleanup: Delete the created caisse transaction\n        if caisse_id is not None:\n            requests.delete(\n                f\"{BASE_URL}/caisses/{caisse_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n        # Cleanup: Delete the created insurance company\n        if assurance_id is not None:\n            requests.delete(\n                f\"{BASE_URL}/assurances/{assurance_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n\ntest_verify_caisse_insurance_coverage()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 107, in <module>\n  File \"<string>\", line 23, in test_verify_caisse_insurance_coverage\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.480Z",
    "modified": "2025-12-02T12:46:02.267Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "d9b82ca6-f206-49e4-9795-800bcd9041bd",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC006-verify_etatcaisse_recette_tracking",
    "description": "Test that EtatCaisse correctly tracks recette (revenue from patient payments) and that it equals total minus insurance coverage when applicable.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = HTTPBasicAuth(\"abdoullah@gmail.com\", \"12345678\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_verify_etatcaisse_recette_tracking():\n    caisse_url = f\"{BASE_URL}/admin/caisses\"\n    etatcaisse_url = f\"{BASE_URL}/admin/etatcaisse\"  # Assuming an admin route to get EtatCaisse entries\n\n    # Create a caisse transaction payload with insurance coverage applied\n    # To test total - insurance coverage = recette, include assurance_id and coverage\n    caisse_payload = {\n        \"patient_id\": 1,           # Must exist or can be dynamically created - using 1 as default for test scope\n        \"medecin_id\": 1,           # Must exist or can be dynamically created - using 1 as default\n        \"total\": 1000.0,\n        \"assurance_id\": 1,         # Insurance present\n        \"couverture\": 30,          # 30% insurance coverage\n        \"mode_paiement_id\": 1,     # Existing payment mode id\n        \"examens_data\": [\n            {\"examen_id\": 1, \"quantity\": 1}\n        ],\n        \"description\": \"Test caisse transaction with insurance coverage\"\n    }\n\n    def create_caisse_transaction():\n        try:\n            response = requests.post(caisse_url, json=caisse_payload, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            assert response.status_code == 201, f\"Unexpected status code when creating caisse: {response.status_code}\"\n            assert response.text.strip() != \"\", \"Empty response received when creating caisse.\"\n            return response.json()\n        except Exception as e:\n            raise AssertionError(f\"Failed to create caisse transaction: {e}\")\n\n    def get_etatcaisse_for_caisse(caisse_id):\n        # Assuming an API to fetch EtatCaisse by caisse_id or filter by caisse_id\n        params = {\"caisse_id\": caisse_id}\n        try:\n            resp = requests.get(etatcaisse_url, auth=AUTH, headers=HEADERS, params=params, timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Unexpected status code when getting EtatCaisse: {resp.status_code}\"\n            assert resp.text.strip() != \"\", \"Empty response received when getting EtatCaisse.\"\n            data = resp.json()\n            # Assuming 1-to-1 mapping for caisse to etatcaisse entry\n            if isinstance(data, list):\n                for entry in data:\n                    if entry.get(\"caisse_id\") == caisse_id:\n                        return entry\n                raise AssertionError(\"EtatCaisse entry for the caisse_id not found\")\n            elif isinstance(data, dict):\n                return data\n            else:\n                raise AssertionError(\"Unexpected response format for EtatCaisse\")\n        except Exception as e:\n            raise AssertionError(f\"Failed to get EtatCaisse data: {e}\")\n\n    caisse = None\n    try:\n        caisse = create_caisse_transaction()\n        assert \"id\" in caisse, \"Caisse transaction creation response missing 'id'.\"\n        caisse_id = caisse[\"id\"]\n\n        etatcaisse_entry = get_etatcaisse_for_caisse(caisse_id)\n\n        assert \"recette\" in etatcaisse_entry, \"EtatCaisse entry missing 'recette'.\"\n        assert \"total\" in etatcaisse_entry, \"EtatCaisse entry missing 'total'.\"\n        assert \"couverture\" in etatcaisse_entry, \"EtatCaisse entry missing 'couverture'.\"\n\n        total = float(etatcaisse_entry[\"total\"])\n        couverture = float(etatcaisse_entry.get(\"couverture\", 0))\n        recette = float(etatcaisse_entry[\"recette\"])\n\n        expected_recette = total * (1 - couverture / 100)\n\n        # Allow minor floating rounding difference\n        assert abs(recette - expected_recette) < 0.01, (\n            f\"Recette {recette} does not equal total minus coverage ({expected_recette}).\"\n        )\n\n    finally:\n        # Clean up by deleting the created caisse transaction if it was created\n        if caisse and \"id\" in caisse:\n            delete_url = f\"{caisse_url}/{caisse['id']}\"\n            try:\n                del_resp = requests.delete(delete_url, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n                del_resp.raise_for_status()\n            except Exception:\n                pass\n\ntest_verify_etatcaisse_recette_tracking()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 31, in create_caisse_transaction\nAssertionError: Unexpected status code when creating caisse: 200\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 60, in test_verify_etatcaisse_recette_tracking\n  File \"<string>\", line 35, in create_caisse_transaction\nAssertionError: Failed to create caisse transaction: Unexpected status code when creating caisse: 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.486Z",
    "modified": "2025-12-02T12:46:10.661Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "ad93b84b-5bac-4d9c-a37d-bdcd7db86f8a",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC007-verify_etatcaisse_validation",
    "description": "Test the validation and unvalidation of EtatCaisse entries, and verify that validated part_medecin is correctly tracked in totals.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = HTTPBasicAuth(\"abdoullah@gmail.com\", \"12345678\")\nHEADERS = {\"Accept\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_verify_etatcaisse_validation():\n    caisse_id = None\n    etatcaisse_id = None\n    try:\n        # Step 1: Create a new caisse transaction to generate EtatCaisse entry\n        caisse_payload = {\n            # Minimal valid payload example with required fields,\n            # since PRD does not provide exact payload, \n            # use plausible fields: medecin_id, total, examenes or similar\n            \"medecin_id\": 1,\n            \"total\": 1000,\n            \"examens_data\": [\n                {\n                    \"examen_id\": 1,\n                    \"quantity\": 1\n                }\n            ],\n            \"mode_paiement\": \"espÃ¨ces\"\n        }\n        response_caisse = requests.post(\n            f\"{BASE_URL}/api/caisses\",\n            json=caisse_payload,\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_caisse.status_code == 201, f\"Caisse creation failed: {response_caisse.text}\"\n        caisse_data = response_caisse.json()\n        caisse_id = caisse_data.get(\"id\")\n        assert caisse_id is not None, \"Created caisse has no ID\"\n        \n        # Step 2: Retrieve EtatCaisse linked to created caisse\n        # Assuming EtatCaisse is listed via /etatcaisse and linked by caisse_id\n        response_etat_list = requests.get(\n            f\"{BASE_URL}/etatcaisse?caisse_id={caisse_id}\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_etat_list.status_code == 200, f\"EtatCaisse list retrieval failed: {response_etat_list.text}\"\n        etat_list = response_etat_list.json()\n        assert isinstance(etat_list, list) and len(etat_list) > 0, \"No EtatCaisse entry found for created caisse\"\n        etatcaisse = etat_list[0]\n        etatcaisse_id = etatcaisse.get(\"id\")\n        assert etatcaisse_id is not None, \"EtatCaisse entry has no ID\"\n        \n        part_medecin_before = etatcaisse.get(\"part_medecin\", 0)\n        validated_before = etatcaisse.get(\"validated\", False)\n        \n        # Step 3: Validate EtatCaisse entry (PUT or PATCH /etatcaisse/{id}/validate)\n        response_validate = requests.put(\n            f\"{BASE_URL}/etatcaisse/{etatcaisse_id}/validate\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_validate.status_code == 200, f\"Validation of EtatCaisse failed: {response_validate.text}\"\n        validate_data = response_validate.json()\n        assert validate_data.get(\"validated\") is True, \"EtatCaisse not marked as validated after validation\"\n        \n        # Step 4: Verify that validated part_medecin is tracked in totals via /etatcaisse/totals or /etatcaisse\n        response_totals = requests.get(\n            f\"{BASE_URL}/etatcaisse/totals\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_totals.status_code == 200, f\"Fetching EtatCaisse totals failed: {response_totals.text}\"\n        totals = response_totals.json()\n        total_part_medecin = totals.get(\"validated_part_medecin\", 0)\n        assert total_part_medecin >= part_medecin_before, \"Validated part_medecin total does not include the validated EtatCaisse\"\n        \n        # Step 5: Unvalidate EtatCaisse entry (PUT or PATCH /etatcaisse/{id}/unvalidate)\n        response_unvalidate = requests.put(\n            f\"{BASE_URL}/etatcaisse/{etatcaisse_id}/unvalidate\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_unvalidate.status_code == 200, f\"Unvalidation of EtatCaisse failed: {response_unvalidate.text}\"\n        unvalidate_data = response_unvalidate.json()\n        assert unvalidate_data.get(\"validated\") is False, \"EtatCaisse still marked as validated after unvalidation\"\n        \n        # Step 6: Verify totals updated accordingly (validated_part_medecin should decrease)\n        response_totals_after = requests.get(\n            f\"{BASE_URL}/etatcaisse/totals\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_totals_after.status_code == 200, f\"Fetching EtatCaisse totals after unvalidate failed: {response_totals_after.text}\"\n        totals_after = response_totals_after.json()\n        total_part_medecin_after = totals_after.get(\"validated_part_medecin\", 0)\n        assert total_part_medecin_after <= total_part_medecin, \"Validated part_medecin total did not decrease after unvalidation\"\n    \n    finally:\n        # Cleanup: Delete created caisse and linked EtatCaisse if exists\n        if etatcaisse_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/etatcaisse/{etatcaisse_id}\",\n                    headers=HEADERS,\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n        if caisse_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/caisses/{caisse_id}\",\n                    headers=HEADERS,\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\ntest_verify_etatcaisse_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 127, in <module>\n  File \"<string>\", line 35, in test_verify_etatcaisse_validation\nAssertionError: Caisse creation failed: {\n    \"message\": \"The route api/caisses could not be found.\",\n    \"exception\": \"Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\NotFoundHttpException\",\n    \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Routing\\\\AbstractRouteCollection.php\",\n    \"line\": 45,\n    \"trace\": [\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Routing\\\\RouteCollection.php\",\n            \"line\": 162,\n            \"function\": \"handleMatchedRoute\",\n            \"class\": \"Illuminate\\\\Routing\\\\AbstractRouteCollection\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Routing\\\\Router.php\",\n            \"line\": 763,\n            \"function\": \"match\",\n            \"class\": \"Illuminate\\\\Routing\\\\RouteCollection\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Routing\\\\Router.php\",\n            \"line\": 750,\n            \"function\": \"findRoute\",\n            \"class\": \"Illuminate\\\\Routing\\\\Router\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Routing\\\\Router.php\",\n            \"line\": 739,\n            \"function\": \"dispatchToRoute\",\n            \"class\": \"Illuminate\\\\Routing\\\\Router\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Kernel.php\",\n            \"line\": 200,\n            \"function\": \"dispatch\",\n            \"class\": \"Illuminate\\\\Routing\\\\Router\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 169,\n            \"function\": \"Illuminate\\\\Foundation\\\\Http\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Kernel\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\livewire\\\\livewire\\\\src\\\\Features\\\\SupportDisablingBackButtonCache\\\\DisableBackButtonCacheMiddleware.php\",\n            \"line\": 19,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Livewire\\\\Features\\\\SupportDisablingBackButtonCache\\\\DisableBackButtonCacheMiddleware\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\app\\\\Http\\\\Middleware\\\\SetLocale.php\",\n            \"line\": 21,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"App\\\\Http\\\\Middleware\\\\SetLocale\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\View\\\\Middleware\\\\ShareErrorsFromSession.php\",\n            \"line\": 48,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\View\\\\Middleware\\\\ShareErrorsFromSession\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Session\\\\Middleware\\\\StartSession.php\",\n            \"line\": 120,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Session\\\\Middleware\\\\StartSession.php\",\n            \"line\": 63,\n            \"function\": \"handleStatefulRequest\",\n            \"class\": \"Illuminate\\\\Session\\\\Middleware\\\\StartSession\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Session\\\\Middleware\\\\StartSession\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Cookie\\\\Middleware\\\\AddQueuedCookiesToResponse.php\",\n            \"line\": 36,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Cookie\\\\Middleware\\\\AddQueuedCookiesToResponse\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\TransformsRequest.php\",\n            \"line\": 21,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\ConvertEmptyStringsToNull.php\",\n            \"line\": 31,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\TransformsRequest\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\ConvertEmptyStringsToNull\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\TransformsRequest.php\",\n            \"line\": 21,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\TrimStrings.php\",\n            \"line\": 51,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\TransformsRequest\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\TrimStrings\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Http\\\\Middleware\\\\ValidatePostSize.php\",\n            \"line\": 27,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Http\\\\Middleware\\\\ValidatePostSize\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\PreventRequestsDuringMaintenance.php\",\n            \"line\": 109,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\PreventRequestsDuringMaintenance\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Http\\\\Middleware\\\\HandleCors.php\",\n            \"line\": 61,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Http\\\\Middleware\\\\HandleCors\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Http\\\\Middleware\\\\TrustProxies.php\",\n            \"line\": 58,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Http\\\\Middleware\\\\TrustProxies\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\InvokeDeferredCallbacks.php\",\n            \"line\": 22,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\InvokeDeferredCallbacks\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Http\\\\Middleware\\\\ValidatePathEncoding.php\",\n            \"line\": 26,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 208,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Http\\\\Middleware\\\\ValidatePathEncoding\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Pipeline\\\\Pipeline.php\",\n            \"line\": 126,\n            \"function\": \"Illuminate\\\\Pipeline\\\\{closure}\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Kernel.php\",\n            \"line\": 175,\n            \"function\": \"then\",\n            \"class\": \"Illuminate\\\\Pipeline\\\\Pipeline\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Http\\\\Kernel.php\",\n            \"line\": 144,\n            \"function\": \"sendRequestThroughRouter\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Kernel\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\Application.php\",\n            \"line\": 1219,\n            \"function\": \"handle\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Http\\\\Kernel\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\public\\\\index.php\",\n            \"line\": 20,\n            \"function\": \"handleRequest\",\n            \"class\": \"Illuminate\\\\Foundation\\\\Application\",\n            \"type\": \"->\"\n        },\n        {\n            \"file\": \"C:\\\\Users\\\\Abdou\\\\Desktop\\\\web\\\\2025-projects\\\\ibnrochd\\\\clinique-ibn-rochd\\\\vendor\\\\laravel\\\\framework\\\\src\\\\Illuminate\\\\Foundation\\\\resources\\\\server.php\",\n            \"line\": 23,\n            \"function\": \"require_once\"\n        }\n    ]\n}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.491Z",
    "modified": "2025-12-02T12:46:15.711Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "66a30d80-d868-4151-b4a0-df0345c19e69",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC008-verify_modepaiement_creation",
    "description": "Test creating ModePaiement entries for caisse transactions and verify that payment type (espÃ¨ces, bankily, masrivi, sedad) is correctly stored.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nbase_endpoint = \"http://localhost:8000\"\nauth = HTTPBasicAuth(\"abdoullah@gmail.com\", \"12345678\")\ntimeout = 30\n\ndef test_verify_modepaiement_creation():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Payment types to test\n    payment_types = [\"espÃ¨ces\", \"bankily\", \"masrivi\", \"sedad\"]\n\n    created_modepaiement_ids = []\n\n    try:\n        for paiement_type in payment_types:\n            # Create a new ModePaiement entry\n            payload = {\n                \"nom\": paiement_type,\n                \"description\": f\"Test payment type {paiement_type}\"\n            }\n            response = requests.post(\n                f\"{base_endpoint}/api/modepaiements\",\n                auth=auth,\n                headers=headers,\n                json=payload,\n                timeout=timeout\n            )\n            assert response.status_code == 201, f\"Failed to create ModePaiement for {paiement_type}\"\n            created_entry = response.json()\n            assert \"id\" in created_entry, \"Created ModePaiement response missing ID\"\n            modepaiement_id = created_entry[\"id\"]\n            created_modepaiement_ids.append(modepaiement_id)\n\n            # Retrieve the created ModePaiement to verify stored data\n            get_response = requests.get(\n                f\"{base_endpoint}/api/modepaiements/{modepaiement_id}\",\n                auth=auth,\n                headers=headers,\n                timeout=timeout\n            )\n            assert get_response.status_code == 200, f\"Failed to retrieve ModePaiement with ID {modepaiement_id}\"\n            data = get_response.json()\n            assert data.get(\"nom\") == paiement_type, f\"Payment type mismatch for ID {modepaiement_id}\"\n            assert data.get(\"description\") == f\"Test payment type {paiement_type}\", f\"Description mismatch for ID {modepaiement_id}\"\n\n    finally:\n        # Cleanup: delete created ModePaiement entries\n        for modepaiement_id in created_modepaiement_ids:\n            del_response = requests.delete(\n                f\"{base_endpoint}/api/modepaiements/{modepaiement_id}\",\n                auth=auth,\n                headers=headers,\n                timeout=timeout\n            )\n            # Allow 200 or 204 for successful deletion\n            assert del_response.status_code in [200, 204], f\"Failed to delete ModePaiement with ID {modepaiement_id}\"\n\ntest_verify_modepaiement_creation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 32, in test_verify_modepaiement_creation\nAssertionError: Failed to create ModePaiement for espÃ¨ces\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.497Z",
    "modified": "2025-12-02T12:46:15.719Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "6e90c4ba-4534-42fc-8fb5-8485467ca3ee",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC009-verify_modepaiement_source_tracking",
    "description": "Test that ModePaiement correctly tracks source (facture, depense, part_medecin, credit_assurance) and filters work correctly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\n\ndef login_get_token(email, password):\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    resp = requests.post(f\"{BASE_URL}/login\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    assert resp.status_code == 200, f\"Login failed: {resp.text}\"\n    data = resp.json()\n    # Assuming the token is returned under 'token' or 'access_token'\n    token = data.get('token') or data.get('access_token')\n    assert token, \"No token found in login response\"\n    return token\n\n\ndef test_verify_modepaiement_source_tracking():\n    token = login_get_token(\"abdoullah@gmail.com\", \"12345678\")\n    auth_headers = HEADERS.copy()\n    auth_headers[\"Authorization\"] = f\"Bearer {token}\"\n\n    created_modepaiement_ids = []\n\n    try:\n        # 1. Create ModePaiement with source \"facture\"\n        facture_payload = {\n            \"montant\": 1000,\n            \"type\": \"espÃ¨ces\",\n            \"source\": \"facture\",\n            \"description\": \"Paiement facture test\"\n        }\n        resp_facture = requests.post(\n            f\"{BASE_URL}/modepaiements\",\n            json=facture_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert resp_facture.status_code == 201, f\"Failed to create facture source ModePaiement: {resp_facture.text}\"\n        facture_data = resp_facture.json()\n        created_modepaiement_ids.append(facture_data[\"id\"])\n\n        # 2. Create ModePaiement with source \"depense\"\n        depense_payload = {\n            \"montant\": 500,\n            \"type\": \"bankily\",\n            \"source\": \"depense\",\n            \"description\": \"Paiement dÃ©pense test\"\n        }\n        resp_depense = requests.post(\n            f\"{BASE_URL}/modepaiements\",\n            json=depense_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert resp_depense.status_code == 201, f\"Failed to create depense source ModePaiement: {resp_depense.text}\"\n        depense_data = resp_depense.json()\n        created_modepaiement_ids.append(depense_data[\"id\"])\n\n        # 3. Create ModePaiement with source \"part_medecin\"\n        part_medecin_payload = {\n            \"montant\": 300,\n            \"type\": \"masrivi\",\n            \"source\": \"part_medecin\",\n            \"description\": \"Paiement part medecin test\"\n        }\n        resp_part_medecin = requests.post(\n            f\"{BASE_URL}/modepaiements\",\n            json=part_medecin_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert resp_part_medecin.status_code == 201, f\"Failed to create part_medecin source ModePaiement: {resp_part_medecin.text}\"\n        part_medecin_data = resp_part_medecin.json()\n        created_modepaiement_ids.append(part_medecin_data[\"id\"])\n\n        # 4. Create ModePaiement with source \"credit_assurance\"\n        credit_assurance_payload = {\n            \"montant\": 800,\n            \"type\": \"sedad\",\n            \"source\": \"credit_assurance\",\n            \"description\": \"Paiement credit assurance test\"\n        }\n        resp_credit_assurance = requests.post(\n            f\"{BASE_URL}/modepaiements\",\n            json=credit_assurance_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert resp_credit_assurance.status_code == 201, f\"Failed to create credit_assurance source ModePaiement: {resp_credit_assurance.text}\"\n        credit_assurance_data = resp_credit_assurance.json()\n        created_modepaiement_ids.append(credit_assurance_data[\"id\"])\n\n        # Verify all created IDs are unique and present\n        ids_set = set(created_modepaiement_ids)\n        assert len(ids_set) == 4, \"Not all ModePaiement entries created successfully with unique IDs.\"\n\n        # Now test filtering by source\n        for source in [\"facture\", \"depense\", \"part_medecin\", \"credit_assurance\"]:\n            resp_filter = requests.get(\n                f\"{BASE_URL}/modepaiements\",\n                headers=auth_headers,\n                timeout=TIMEOUT,\n                params={\"source\": source}\n            )\n            assert resp_filter.status_code == 200, f\"Failed to get ModePaiement filtered by source {source}: {resp_filter.text}\"\n            list_data = resp_filter.json()\n            # The list should contain at least one entry with the source requested\n            assert any(mp.get(\"source\") == source for mp in list_data), f\"No ModePaiement found for source {source}\"\n\n    finally:\n        # Cleanup: delete created ModePaiement entries\n        for mp_id in created_modepaiement_ids:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/modepaiements/{mp_id}\",\n                    headers=auth_headers,\n                    timeout=TIMEOUT\n                )\n                assert del_resp.status_code in (200, 204), f\"Failed to delete ModePaiement id {mp_id}: {del_resp.text}\"\n            except Exception:\n                pass\n\n\ntest_verify_modepaiement_source_tracking()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 133, in <module>\n  File \"<string>\", line 27, in test_verify_modepaiement_source_tracking\n  File \"<string>\", line 18, in login_get_token\nAssertionError: Login failed: {\"message\":\"Unauthenticated.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.503Z",
    "modified": "2025-12-02T12:46:54.580Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "9b0361ad-0acb-4262-b6d1-62d76ba38232",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC010-verify_modepaiement_totals_calculation",
    "description": "Test that ModePaiement dashboard correctly calculates totals by payment type (espÃ¨ces vs numÃ©rique) and by source (factures vs depenses vs part_medecin).",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = (\"abdoullah@gmail.com\", \"12345678\")\nHEADERS = {\"Accept\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_verify_modepaiement_totals_calculation():\n    \"\"\"\n    Test that ModePaiement dashboard correctly calculates totals by payment type (espÃ¨ces vs numÃ©rique) and by source (factures vs depenses vs part_medecin).\n    \"\"\"\n    session = requests.Session()\n    session.auth = AUTH\n    session.headers.update(HEADERS)\n\n    created_caisse_id = None\n    created_depense_id = None\n    created_part_medecin_modepaiement_id = None\n\n    try:\n        # Step 1: Create a caisse transaction with ModePaiement entries covering espÃ¨ces and numÃ©rique, sources = factures and part_medecin\n\n        # Create a caisse transaction (facture) with ModePaiement\n        caisse_payload = {\n            \"date\": \"2025-11-19\",\n            \"total\": 1500.0,\n            \"medecin_id\": 1,\n            \"mode_paiements\": [\n                {\"type\": \"espÃ¨ces\", \"source\": \"facture\", \"montant\": 500.0},\n                {\"type\": \"numÃ©rique\", \"source\": \"facture\", \"montant\": 1000.0}\n            ]\n        }\n        resp_caisse = session.post(f\"{BASE_URL}/superadmin/caisses\", json=caisse_payload, timeout=TIMEOUT)\n        assert resp_caisse.status_code == 201, f\"Create caisse failed: {resp_caisse.text}\"\n        caisse_data = resp_caisse.json()\n        created_caisse_id = caisse_data.get(\"id\")\n        assert created_caisse_id is not None, \"Created caisse has no ID\"\n\n        # Step 2: Create a depense with ModePaiement entries (espÃ¨ces and numÃ©rique), source=depense\n        depense_payload = {\n            \"date\": \"2025-11-19\",\n            \"montant\": 800.0,\n            \"description\": \"Test depense for ModePaiement totals\",\n            \"mode_paiement\": {\"type\": \"espÃ¨ces\", \"source\": \"depense\", \"montant\": 800.0}\n        }\n        resp_depense = session.post(f\"{BASE_URL}/depenses\", json=depense_payload, timeout=TIMEOUT)\n        assert resp_depense.status_code == 201, f\"Create depense failed: {resp_depense.text}\"\n        depense_data = resp_depense.json()\n        created_depense_id = depense_data.get(\"id\")\n        assert created_depense_id is not None, \"Created depense has no ID\"\n\n        # Step 3: Create a ModePaiement entry for part_medecin source separately (simulate part_medecin receipt)\n        part_medecin_payload = {\n            \"type\": \"numÃ©rique\",\n            \"source\": \"part_medecin\",\n            \"montant\": 300.0,\n            \"date\": \"2025-11-19\",\n            \"description\": \"Part medecin payment\"\n        }\n        resp_part_medecin = session.post(f\"{BASE_URL}/modepaiements\", json=part_medecin_payload, timeout=TIMEOUT)\n        assert resp_part_medecin.status_code == 201, f\"Create part_medecin ModePaiement failed: {resp_part_medecin.text}\"\n        part_medecin_data = resp_part_medecin.json()\n        created_part_medecin_modepaiement_id = part_medecin_data.get(\"id\")\n        assert created_part_medecin_modepaiement_id is not None, \"Created part_medecin ModePaiement has no ID\"\n\n        # Step 4: Get ModePaiement dashboard totals summary endpoint\n        resp_dashboard = session.get(f\"{BASE_URL}/modepaiements/dashboard-totals\", timeout=TIMEOUT)\n        assert resp_dashboard.status_code == 200, f\"Fetching ModePaiement dashboard totals failed: {resp_dashboard.text}\"\n        totals = resp_dashboard.json()\n\n        # Expected totals calculation (from created data):\n        # By payment type:\n        # espÃ¨ces: 500.0 (facture) + 800.0 (depense) = 1300.0\n        # numÃ©rique: 1000.0 (facture) + 300.0 (part_medecin) = 1300.0\n        #\n        # By source:\n        # factures: 1500.0 (500+1000)\n        # depenses: 800.0\n        # part_medecin: 300.0\n\n        # Validate totals by payment type\n        espÃ¨ces_total = totals.get(\"by_payment_type\", {}).get(\"espÃ¨ces\")\n        numÃ©rique_total = totals.get(\"by_payment_type\", {}).get(\"numÃ©rique\")\n\n        assert espÃ¨ces_total is not None, \"espÃ¨ces total missing in dashboard totals\"\n        assert numÃ©rique_total is not None, \"numÃ©rique total missing in dashboard totals\"\n        assert abs(espÃ¨ces_total - 1300.0) < 0.01, f\"espÃ¨ces total mismatch: expected 1300.0, got {espÃ¨ces_total}\"\n        assert abs(numÃ©rique_total - 1300.0) < 0.01, f\"numÃ©rique total mismatch: expected 1300.0, got {numÃ©rique_total}\"\n\n        # Validate totals by source\n        factures_total = totals.get(\"by_source\", {}).get(\"facture\")\n        depenses_total = totals.get(\"by_source\", {}).get(\"depense\")\n        part_medecin_total = totals.get(\"by_source\", {}).get(\"part_medecin\")\n\n        assert factures_total is not None, \"facture total missing in dashboard totals\"\n        assert depenses_total is not None, \"depense total missing in dashboard totals\"\n        assert part_medecin_total is not None, \"part_medecin total missing in dashboard totals\"\n\n        assert abs(factures_total - 1500.0) < 0.01, f\"facture total mismatch: expected 1500.0, got {factures_total}\"\n        assert abs(depenses_total - 800.0) < 0.01, f\"depense total mismatch: expected 800.0, got {depenses_total}\"\n        assert abs(part_medecin_total - 300.0) < 0.01, f\"part_medecin total mismatch: expected 300.0, got {part_medecin_total}\"\n\n    finally:\n        # Clean up created resources\n        if created_part_medecin_modepaiement_id:\n            session.delete(f\"{BASE_URL}/modepaiements/{created_part_medecin_modepaiement_id}\", timeout=TIMEOUT)\n        if created_depense_id:\n            session.delete(f\"{BASE_URL}/depenses/{created_depense_id}\", timeout=TIMEOUT)\n        if created_caisse_id:\n            session.delete(f\"{BASE_URL}/superadmin/caisses/{created_caisse_id}\", timeout=TIMEOUT)\n\ntest_verify_modepaiement_totals_calculation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 112, in <module>\n  File \"<string>\", line 34, in test_verify_modepaiement_totals_calculation\nAssertionError: Create caisse failed: {\"message\":\"Unauthenticated.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.509Z",
    "modified": "2025-12-02T12:47:16.266Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "0e17e883-223f-4b47-9bbb-102b05b244e9",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC011-verify_depense_creation",
    "description": "Test creating a Depense entry with payment mode and verify that it's correctly stored and linked to ModePaiement.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000/api\"\nTIMEOUT = 30\nAUTH = HTTPBasicAuth(\"abdoullah@gmail.com\", \"12345678\")\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_verify_depense_creation():\n    depense_id = None\n    try:\n        # Use an existing modepaiement_id since creation endpoint does not exist\n        modepaiement_id = 1  # Assumed existing payment mode ID\n\n        # Create a Depense linked to the existing ModePaiement\n        depense_payload = {\n            \"montant\": 150.50,\n            \"description\": \"Test depense with payment mode\",\n            \"modepaiement_id\": modepaiement_id,\n            \"date_depense\": \"2025-11-19\"\n        }\n        depense_response = requests.post(\n            f\"{BASE_URL}/depenses\",\n            json=depense_payload,\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT,\n        )\n        assert depense_response.status_code == 201, f\"Failed to create Depense: {depense_response.text}\"\n        depense_data = depense_response.json()\n        depense_id = depense_data.get(\"id\")\n        assert depense_id is not None, \"Depense creation response missing 'id'\"\n\n        # Retrieve the created Depense and verify\n        get_depense_response = requests.get(\n            f\"{BASE_URL}/depenses/{depense_id}\",\n            headers=HEADERS,\n            auth=AUTH,\n            timeout=TIMEOUT,\n        )\n        assert get_depense_response.status_code == 200, f\"Failed to get Depense: {get_depense_response.text}\"\n        retrieved_depense = get_depense_response.json()\n\n        # Validate fields\n        assert abs(float(retrieved_depense.get(\"montant\", 0)) - 150.50) < 0.01, \"Depense montant does not match\"\n        assert retrieved_depense.get(\"description\") == \"Test depense with payment mode\", \"Depense description mismatch\"\n        assert str(retrieved_depense.get(\"modepaiement_id\")) == str(modepaiement_id), \"Depense modepaiement_id mismatch\"\n\n    finally:\n        # Cleanup: Delete created Depense if it exists\n        if depense_id:\n            requests.delete(\n                f\"{BASE_URL}/depenses/{depense_id}\",\n                headers=HEADERS,\n                auth=AUTH,\n                timeout=TIMEOUT,\n            )\n\n\ntest_verify_depense_creation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 61, in <module>\n  File \"<string>\", line 30, in test_verify_depense_creation\nAssertionError: Failed to create Depense: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>Not Found</title>\n\n        <style>\n            /*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}a{background-color:transparent}code{font-family:monospace,monospace;font-size:1em}[hidden]{display:none}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5}*,:after,:before{box-sizing:border-box;border:0 solid #e2e8f0}a{color:inherit;text-decoration:inherit}code{font-family:Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}svg,video{display:block;vertical-align:middle}video{max-width:100%;height:auto}.bg-white{--bg-opacity:1;background-color:#fff;background-color:rgba(255,255,255,var(--bg-opacity))}.bg-gray-100{--bg-opacity:1;background-color:#f7fafc;background-color:rgba(247,250,252,var(--bg-opacity))}.border-gray-200{--border-opacity:1;border-color:#edf2f7;border-color:rgba(237,242,247,var(--border-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-t{border-top-width:1px}.border-r{border-right-width:1px}.flex{display:flex}.grid{display:grid}.hidden{display:none}.items-center{align-items:center}.justify-center{justify-content:center}.font-semibold{font-weight:600}.h-5{height:1.25rem}.h-8{height:2rem}.h-16{height:4rem}.text-sm{font-size:.875rem}.text-lg{font-size:1.125rem}.leading-7{line-height:1.75rem}.mx-auto{margin-left:auto;margin-right:auto}.ml-1{margin-left:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.ml-2{margin-left:.5rem}.mt-4{margin-top:1rem}.ml-4{margin-left:1rem}.mt-8{margin-top:2rem}.ml-12{margin-left:3rem}.-mt-px{margin-top:-1px}.max-w-xl{max-width:36rem}.max-w-6xl{max-width:72rem}.min-h-screen{min-height:100vh}.overflow-hidden{overflow:hidden}.p-6{padding:1.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pt-8{padding-top:2rem}.fixed{position:fixed}.relative{position:relative}.top-0{top:0}.right-0{right:0}.shadow{box-shadow:0 1px 3px 0 rgba(0,0,0,.1),0 1px 2px 0 rgba(0,0,0,.06)}.text-center{text-align:center}.text-gray-200{--text-opacity:1;color:#edf2f7;color:rgba(237,242,247,var(--text-opacity))}.text-gray-300{--text-opacity:1;color:#e2e8f0;color:rgba(226,232,240,var(--text-opacity))}.text-gray-400{--text-opacity:1;color:#cbd5e0;color:rgba(203,213,224,var(--text-opacity))}.text-gray-500{--text-opacity:1;color:#a0aec0;color:rgba(160,174,192,var(--text-opacity))}.text-gray-600{--text-opacity:1;color:#718096;color:rgba(113,128,150,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-900{--text-opacity:1;color:#1a202c;color:rgba(26,32,44,var(--text-opacity))}.uppercase{text-transform:uppercase}.underline{text-decoration:underline}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.tracking-wider{letter-spacing:.05em}.w-5{width:1.25rem}.w-8{width:2rem}.w-auto{width:auto}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}@-webkit-keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@-webkit-keyframes ping{0%{transform:scale(1);opacity:1}75%,to{transform:scale(2);opacity:0}}@keyframes ping{0%{transform:scale(1);opacity:1}75%,to{transform:scale(2);opacity:0}}@-webkit-keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@-webkit-keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:translateY(0);-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:translateY(0);-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@media (min-width:640px){.sm\\:rounded-lg{border-radius:.5rem}.sm\\:block{display:block}.sm\\:items-center{align-items:center}.sm\\:justify-start{justify-content:flex-start}.sm\\:justify-between{justify-content:space-between}.sm\\:h-20{height:5rem}.sm\\:ml-0{margin-left:0}.sm\\:px-6{padding-left:1.5rem;padding-right:1.5rem}.sm\\:pt-0{padding-top:0}.sm\\:text-left{text-align:left}.sm\\:text-right{text-align:right}}@media (min-width:768px){.md\\:border-t-0{border-top-width:0}.md\\:border-l{border-left-width:1px}.md\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media (min-width:1024px){.lg\\:px-8{padding-left:2rem;padding-right:2rem}}@media (prefers-color-scheme:dark){.dark\\:bg-gray-800{--bg-opacity:1;background-color:#2d3748;background-color:rgba(45,55,72,var(--bg-opacity))}.dark\\:bg-gray-900{--bg-opacity:1;background-color:#1a202c;background-color:rgba(26,32,44,var(--bg-opacity))}.dark\\:border-gray-700{--border-opacity:1;border-color:#4a5568;border-color:rgba(74,85,104,var(--border-opacity))}.dark\\:text-white{--text-opacity:1;color:#fff;color:rgba(255,255,255,var(--text-opacity))}.dark\\:text-gray-400{--text-opacity:1;color:#cbd5e0;color:rgba(203,213,224,var(--text-opacity))}}\n        </style>\n\n        <style>\n            body {\n                font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n            }\n        </style>\n    </head>\n    <body class=\"antialiased\">\n        <div class=\"relative flex items-top justify-center min-h-screen bg-gray-100 dark:bg-gray-900 sm:items-center sm:pt-0\">\n            <div class=\"max-w-xl mx-auto sm:px-6 lg:px-8\">\n                <div class=\"flex items-center pt-8 sm:justify-start sm:pt-0\">\n                    <div class=\"px-4 text-lg text-gray-500 border-r border-gray-400 tracking-wider\">\n                        404                    </div>\n\n                    <div class=\"ml-4 text-lg text-gray-500 uppercase tracking-wider\">\n                        Not Found                    </div>\n                </div>\n            </div>\n        </div>\n    </body>\n</html>\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.514Z",
    "modified": "2025-12-02T12:47:05.819Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "9f13bbee-5ad7-429f-b5d2-fe1fffdd6174",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC012-verify_depense_part_medecin_source",
    "description": "Test that depenses with source 'part_medecin' are correctly identified and filtered, and that they represent doctor share payments.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = HTTPBasicAuth('abdoullah@gmail.com', '12345678')\nHEADERS = {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json'\n}\nTIMEOUT = 30\n\ndef test_verify_depense_part_medecin_source():\n    depense_id = None\n    try:\n        # Step 1: Create a depense with source 'part_medecin'\n        depense_payload = {\n            \"montant\": 150.0,\n            \"description\": \"Paiement part mÃ©decin test\",\n            \"source\": \"part_medecin\",\n            \"mode_paiement_id\": None  # Assuming mode_paiement is optional or we can fetch one\n        }\n\n        # Fetch existing ModePaiement with source 'part_medecin' or any valid ModePaiement for linking\n        mode_paiement_resp = requests.get(f\"{BASE_URL}/modepaiements\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        if mode_paiement_resp.status_code == 200:\n            mp_items = mode_paiement_resp.json()\n            if isinstance(mp_items, list) and len(mp_items) > 0:\n                part_medecin_mode = next((mp for mp in mp_items if mp.get(\"source\") == \"part_medecin\"), None)\n                if part_medecin_mode:\n                    depense_payload[\"mode_paiement_id\"] = part_medecin_mode.get(\"id\")\n                else:\n                    # fallback assign first mode_paiement id if available\n                    depense_payload[\"mode_paiement_id\"] = mp_items[0].get(\"id\")\n\n        # Create the depense\n        resp_create = requests.post(f\"{BASE_URL}/depenses\", json=depense_payload, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_create.status_code == 201, f\"Failed to create depense, status: {resp_create.status_code}, response: {resp_create.text}\"\n        depense_data = resp_create.json()\n        depense_id = depense_data.get(\"id\")\n        assert depense_id is not None, \"Created depense does not have an ID\"\n\n        # Step 2: Fetch depenses filtered by source=part_medecin\n        resp_filter = requests.get(f\"{BASE_URL}/depenses\", params={\"source\": \"part_medecin\"}, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_filter.status_code == 200, f\"Failed to get filtered depenses, status: {resp_filter.status_code}, response: {resp_filter.text}\"\n        depenses = resp_filter.json()\n        assert isinstance(depenses, list), \"Expected a list of depenses\"\n\n        # Step 3: Verify the created depense is in the filtered list and all have source 'part_medecin'\n        filtered_ids = [dep.get(\"id\") for dep in depenses if dep.get(\"source\") == \"part_medecin\"]\n        assert depense_id in filtered_ids, \"Created depense with source 'part_medecin' not found in filtered depenses\"\n        for dep in depenses:\n            assert dep.get(\"source\") == \"part_medecin\", f\"Found depense with source != 'part_medecin': {dep}\"\n\n    finally:\n        # Cleanup: Delete the created depense if exists\n        if depense_id:\n            requests.delete(f\"{BASE_URL}/depenses/{depense_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n\ntest_verify_depense_part_medecin_source()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 59, in <module>\n  File \"<string>\", line 37, in test_verify_depense_part_medecin_source\nAssertionError: Failed to create depense, status: 401, response: {\"message\":\"Unauthenticated.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.520Z",
    "modified": "2025-12-02T12:47:05.821Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "1ab02de7-70ce-4223-944b-ba49ed1d6f24",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC013-verify_credit_creation_for_assurance",
    "description": "Test that when a caisse transaction includes insurance, a Credit is automatically created for the Assurance with correct montant calculation (total * couverture / 100).",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = (\"abdoullah@gmail.com\", \"12345678\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_verify_credit_creation_for_assurance():\n    caisse_url = f\"{BASE_URL}/api/caisses\"\n    credits_url = f\"{BASE_URL}/credits\"\n    assurances_url = f\"{BASE_URL}/assurances\"\n\n    # Step 1: Create a test insurance (assurance) to be referenced in the caisse transaction\n    insurance_payload = {\n        \"nom\": \"Test Assurance\",\n        \"couverture\": 20  # 20% coverage\n    }\n\n    insurance_id = None\n    caisse_id = None\n    credit_id = None\n    try:\n        resp_assurance = requests.post(assurances_url, json=insurance_payload, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_assurance.status_code in (200, 201), f\"Failed to create insurance, status {resp_assurance.status_code}\"\n        insurance_data = resp_assurance.json()\n        insurance_id = insurance_data.get(\"id\")\n        assert insurance_id is not None, \"Insurance ID missing in response\"\n\n        # Step 2: Create a caisse transaction including the insurance\n        # Assuming minimal required fields and a 'total' field for amount\n        # Example total: 1000 for easier calculation (coverage 20% -> 200 credit)\n        caisse_payload = {\n            \"patient_id\": 1,       # Assuming patient with ID 1 exists for test\n            \"medecin_id\": 1,       # Assuming doctor with ID 1 exists for test\n            \"total\": 1000,\n            \"assurance_id\": insurance_id,\n            \"description\": \"Test transaction with insurance coverage\"\n        }\n\n        resp_caisse = requests.post(caisse_url, json=caisse_payload, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_caisse.status_code == 201, f\"Failed to create caisse transaction, status {resp_caisse.status_code}\"\n        caisse_data = resp_caisse.json()\n        caisse_id = caisse_data.get(\"id\")\n        total = caisse_data.get(\"total\")\n        assert caisse_id is not None, \"Caisse transaction ID missing in response\"\n\n        # Step 3: Verify a Credit was created for the Assurance with correct montant calculation\n        # Credit amount = total * couverture / 100\n        expected_credit_montant = total * insurance_payload[\"couverture\"] / 100\n\n        # Search credits linked to this insurance\n        resp_credits = requests.get(credits_url, auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_credits.status_code == 200, f\"Failed to get credits, status {resp_credits.status_code}\"\n        credits_list = resp_credits.json()\n\n        # Filter credits for this insurance and caisse transaction\n        related_credits = [\n            c for c in credits_list\n            if c.get(\"assurance_id\") == insurance_id and c.get(\"caisse_id\") == caisse_id\n        ]\n        assert len(related_credits) > 0, \"No credit created for the insurance linked to caisse\"\n\n        # Check montant correctness in first related Credit\n        credit = related_credits[0]\n        credit_id = credit.get(\"id\")\n        montant = credit.get(\"montant\")\n        assert montant is not None, \"Credit montant missing\"\n        # Assert montant is approximately equal (float tolerance)\n        assert abs(montant - expected_credit_montant) < 0.01, (\n            f\"Credit montant incorrect: expected {expected_credit_montant}, got {montant}\"\n        )\n\n    finally:\n        # Cleanup: Delete created Credit\n        if credit_id is not None:\n            try:\n                requests.delete(f\"{credits_url}/{credit_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        # Cleanup: Delete created caisse transaction\n        if caisse_id is not None:\n            try:\n                requests.delete(f\"{caisse_url}/{caisse_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        # Cleanup: Delete created insurance\n        if insurance_id is not None:\n            try:\n                requests.delete(f\"{assurances_url}/{insurance_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_verify_credit_creation_for_assurance()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/requests/models.py\", line 974, in json\n    return complexjson.loads(self.text, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/__init__.py\", line 514, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 386, in decode\n    obj, end = self.raw_decode(s)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 416, in raw_decode\n    return self.scan_once(s, idx=_w(s, idx).end())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nsimplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 93, in <module>\n  File \"<string>\", line 25, in test_verify_credit_creation_for_assurance\n  File \"/var/task/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nrequests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.526Z",
    "modified": "2025-12-02T12:46:59.159Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "28135aa1-1530-4a19-a1aa-5af2dbfa80d9",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC014-verify_credit_payment_processing",
    "description": "Test credit payment processing (payer) and verify that montant_paye is correctly updated and status changes accordingly.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = (\"abdoullah@gmail.com\", \"12345678\")\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_verify_credit_payment_processing():\n    credit_id = None\n    try:\n        # Step 1: Create a Credit to test payment processing\n        # Create a caisse transaction with insurance to generate a Credit or create Credit directly if API allows\n        \n        # For test simplicity, create a credit resource directly if API supports POST /credits\n        credit_payload = {\n            \"patient_id\": 1,      # assuming patient 1 exists; else create patient then use its id\n            \"assurance_id\": 1,    # assuming assurance 1 exists\n            \"total\": 1000,\n            \"montant_paye\": 0,\n            \"status\": \"en attente\"  # assumed initial status \"pending\"\n        }\n        credit_create_resp = requests.post(\n            f\"{BASE_URL}/credits\",\n            auth=AUTH,\n            headers=HEADERS,\n            data=json.dumps(credit_payload),\n            timeout=30\n        )\n        assert credit_create_resp.status_code in (200, 201), f\"Expected 200 or 201 Created, got {credit_create_resp.status_code}\"\n        credit_data = credit_create_resp.json()\n        credit_id = credit_data.get(\"id\")\n        assert credit_id is not None, \"Credit ID not returned on creation\"\n        assert credit_data.get(\"montant_paye\") == 0\n        assert credit_data.get(\"status\") == \"en attente\" or credit_data.get(\"status\") == \"pending\"\n        \n        # Step 2: Make a payment request on the credit to pay some amount\n        pay_amount = 600\n        payer_payload = {\"montant\": pay_amount}\n        payer_resp = requests.post(\n            f\"{BASE_URL}/credits/{credit_id}/payer\",\n            auth=AUTH,\n            headers=HEADERS,\n            data=json.dumps(payer_payload),\n            timeout=30\n        )\n        assert payer_resp.status_code in (200, 201), f\"Expected 200 or 201 on payment, got {payer_resp.status_code}\"\n        payer_data = payer_resp.json()\n        \n        # Validate montant_paye updated properly and status changed accordingly\n        montant_paye = payer_data.get(\"montant_paye\")\n        assert montant_paye is not None, \"montant_paye missing in payment response\"\n        assert montant_paye == pay_amount, f\"montant_paye expected {pay_amount}, got {montant_paye}\"\n        \n        status = payer_data.get(\"status\")\n        assert status in (\"partiel\", \"en cours\", \"pending\"), f\"Unexpected status after partial payment: {status}\"\n        \n        # Step 3: Pay the remaining amount to complete credit payment and check status changes\n        remaining_amount = credit_data[\"total\"] - montant_paye\n        if remaining_amount > 0:\n            payer_resp_2 = requests.post(\n                f\"{BASE_URL}/credits/{credit_id}/payer\",\n                auth=AUTH,\n                headers=HEADERS,\n                data=json.dumps({\"montant\": remaining_amount}),\n                timeout=30\n            )\n            assert payer_resp_2.status_code in (200, 201), f\"Expected 200 or 201 on final payment, got {payer_resp_2.status_code}\"\n            payer_data_2 = payer_resp_2.json()\n            assert payer_data_2.get(\"montant_paye\") == credit_data[\"total\"], f\"montant_paye expected {credit_data['total']}, got {payer_data_2.get('montant_paye')}\"\n            assert payer_data_2.get(\"status\") == \"paid\" or payer_data_2.get(\"status\") == \"termine\", f\"Expected status 'paid' or 'termine', got {payer_data_2.get('status')}\"\n        \n    finally:\n        # Clean up: Delete the created credit if possible\n        if credit_id:\n            requests.delete(\n                f\"{BASE_URL}/credits/{credit_id}\",\n                auth=AUTH,\n                headers=HEADERS,\n                timeout=30\n            )\n\ntest_verify_credit_payment_processing()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/requests/models.py\", line 974, in json\n    return complexjson.loads(self.text, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/__init__.py\", line 514, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 386, in decode\n    obj, end = self.raw_decode(s)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 416, in raw_decode\n    return self.scan_once(s, idx=_w(s, idx).end())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nsimplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 82, in <module>\n  File \"<string>\", line 30, in test_verify_credit_payment_processing\n  File \"/var/task/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nrequests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.531Z",
    "modified": "2025-12-02T12:47:13.865Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "76a200e4-7336-42b9-a951-72c22196d028",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC015-verify_etatcaisse_general_generation",
    "description": "Test generating general EtatCaisse report (/etatcaisse/generer/general) and verify it includes correct totals for recette, part_medecin, part_clinique, depenses, and credits.",
    "code": "import requests\n\ndef test_verify_etatcaisse_general_generation():\n    base_url = \"http://localhost:8000\"\n    login_url = f\"{base_url}/login\"\n    etatcaisse_url = f\"{base_url}/etatcaisse/general\"\n    headers = {\"Accept\": \"application/json\"}\n    timeout = 30\n\n    # Credentials for login\n    login_data = {\n        \"email\": \"abdoullah@gmail.com\",\n        \"password\": \"12345678\"\n    }\n\n    session = requests.Session()\n\n    try:\n        # Perform login\n        login_response = session.post(login_url, data=login_data, headers={\"Accept\": \"application/json\"}, timeout=timeout)\n        login_response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {str(e)}\"\n\n    # Verify login success by checking if session cookie is set or status code\n    if not session.cookies:\n        assert False, \"Login failed, no session cookie received\"\n\n    try:\n        response = session.get(etatcaisse_url, headers=headers, timeout=timeout)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to generate general EtatCaisse report failed: {str(e)}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Verify keys exist in the response\n    assert \"totaux\" in data, \"Response JSON missing 'totaux' key\"\n    totaux = data[\"totaux\"]\n\n    required_fields = [\"recette\", \"part_medecin\", \"part_clinique\", \"depenses\", \"credits\"]\n    for field in required_fields:\n        assert field in totaux, f\"Key '{field}' missing in 'totaux'\"\n\n        value = totaux[field]\n        assert isinstance(value, (int, float)), f\"Value for '{field}' should be a number\"\n        assert value >= 0, f\"Value for '{field}' should be non-negative\"\n\n    recette = totaux[\"recette\"]\n    part_medecin = totaux[\"part_medecin\"]\n    part_clinique = totaux[\"part_clinique\"]\n\n    assert recette >= part_medecin, \"recette should be greater or equal to part_medecin\"\n    assert recette >= part_clinique, \"recette should be greater or equal to part_clinique\"\n\n\ntest_verify_etatcaisse_general_generation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 21, in test_verify_etatcaisse_general_generation\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:8000/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 60, in <module>\n  File \"<string>\", line 23, in test_verify_etatcaisse_general_generation\nAssertionError: Login request failed: 401 Client Error: Unauthorized for url: http://localhost:8000/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.538Z",
    "modified": "2025-12-02T12:47:24.890Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "337b12f0-6301-45b5-9a81-efd72458efbc",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC016-verify_situation_journaliere_daily_report",
    "description": "Test the daily situation report (/situation-journaliere) and verify it correctly breaks down financial data by service categories with doctor shares and clinic shares.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nUSERNAME = \"abdoullah@gmail.com\"\nPASSWORD = \"12345678\"\n\ndef test_verify_situation_journaliere_daily_report():\n    \"\"\"Test the daily situation report (/superadmin/situation-journaliere) and verify breakdown of financial data.\"\"\"\n\n    url = f\"{BASE_URL}/superadmin/situation-journaliere\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, auth=HTTPBasicAuth(USERNAME, PASSWORD), timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    data = response.json()\n\n    # Validate general structure\n    assert isinstance(data, dict), \"Response should be a JSON object\"\n\n    assert \"services\" in data, \"'services' key must be present in response\"\n    assert isinstance(data[\"services\"], list), \"'services' should be a list\"\n\n    for service in data[\"services\"]:\n        assert isinstance(service, dict), \"Each service entry should be a dict\"\n        for key in [\"service_name\", \"total_recette\", \"part_medecin\", \"part_clinique\", \"depenses\"]:\n            assert key in service, f\"Key '{key}' missing in service entry\"\n        \n        assert isinstance(service[\"service_name\"], str), \"'service_name' should be a string\"\n        assert isinstance(service[\"total_recette\"], (int, float)), \"'total_recette' should be numeric\"\n        assert isinstance(service[\"part_medecin\"], (int, float)), \"'part_medecin' should be numeric\"\n        assert isinstance(service[\"part_clinique\"], (int, float)), \"'part_clinique' should be numeric\"\n        assert isinstance(service[\"depenses\"], (int, float)), \"'depenses' should be numeric\"\n\n        # Financial logic assertions (non-negative values)\n        assert service[\"total_recette\"] >= 0, \"total_recette must be >= 0\"\n        assert service[\"part_medecin\"] >= 0, \"part_medecin must be >= 0\"\n        assert service[\"part_clinique\"] >= 0, \"part_clinique must be >= 0\"\n        assert service[\"depenses\"] >= 0, \"depenses must be >= 0\"\n\n        # part_medecin + part_clinique should not exceed total_recette\n        assert service[\"part_medecin\"] + service[\"part_clinique\"] <= service[\"total_recette\"] + 0.01, \\\n            \"Sum of part_medecin and part_clinique should not exceed total_recette\"\n\n    assert \"total\" in data, \"'total' key must be present in response\"\n    total = data[\"total\"]\n    for key in [\"recette\", \"part_medecin\", \"part_clinique\", \"depenses\"]:\n        assert key in total, f\"Key '{key}' missing in total summary\"\n        assert isinstance(total[key], (int, float)), f\"Total {key} should be numeric\"\n        assert total[key] >= 0, f\"Total {key} must be >= 0\"\n\n    # totals sanity: total recette should be >= sum of parts for all services (allow tiny float rounding)\n    sum_recette = sum(s[\"total_recette\"] for s in data[\"services\"])\n    sum_part_medecin = sum(s[\"part_medecin\"] for s in data[\"services\"])\n    sum_part_clinique = sum(s[\"part_clinique\"] for s in data[\"services\"])\n    sum_depenses = sum(s[\"depenses\"] for s in data[\"services\"])\n\n    assert abs(total[\"recette\"] - sum_recette) < 0.1, \"total recette mismatch vs sum of services\"\n    assert abs(total[\"part_medecin\"] - sum_part_medecin) < 0.1, \"total part_medecin mismatch vs sum of services\"\n    assert abs(total[\"part_clinique\"] - sum_part_clinique) < 0.1, \"total part_clinique mismatch vs sum of services\"\n    assert abs(total[\"depenses\"] - sum_depenses) < 0.1, \"total depenses mismatch vs sum of services\"\n\ntest_verify_situation_journaliere_daily_report()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 19, in test_verify_situation_journaliere_daily_report\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:8000/superadmin/situation-journaliere\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 21, in test_verify_situation_journaliere_daily_report\nAssertionError: Request to http://localhost:8000/superadmin/situation-journaliere failed: 401 Client Error: Unauthorized for url: http://localhost:8000/superadmin/situation-journaliere\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.544Z",
    "modified": "2025-12-02T12:47:46.658Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "9e436365-ff26-4b93-b0a1-0aea14f419b1",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC017-verify_multiple_examens_in_caisse",
    "description": "Test creating a caisse transaction with multiple examinations (examens_data) and verify that part_medecin and part_clinique are correctly summed from all examinations.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nAUTH_USERNAME = \"abdoullah@gmail.com\"\nAUTH_PASSWORD = \"12345678\"\nTIMEOUT = 30\n\ndef test_verify_multiple_examens_in_caisse():\n    session = requests.Session()\n    headers = {'Content-Type': 'application/json'}\n\n    # Perform login to obtain authenticated session cookie and CSRF token\n    login_url = f\"{BASE_URL}/login\"\n\n    # Get login page to fetch CSRF token\n    resp_login_page = session.get(login_url, timeout=TIMEOUT)\n    assert resp_login_page.status_code == 200, f\"Failed to get login page: {resp_login_page.status_code}\"\n\n    # Extract CSRF token from HTML\n    import re\n    csrf_token_match = re.search(r'name=\"_token\" value=\"([^\"]+)\"', resp_login_page.text)\n    assert csrf_token_match, \"CSRF token not found on login page\"\n    csrf_token = csrf_token_match.group(1)\n\n    # Post credentials to login form\n    login_payload = {\n        '_token': csrf_token,\n        'email': AUTH_USERNAME,\n        'password': AUTH_PASSWORD\n    }\n    resp_login = session.post(login_url, data=login_payload, timeout=TIMEOUT, allow_redirects=False)\n    # After successful login, status code should be 302 redirect\n    assert resp_login.status_code in [302, 303], f\"Login failed with status code {resp_login.status_code}\"\n\n    # Now session is authenticated\n\n    # Step 1: Create multiple examens to be used in the caisse transaction\n    examens_data = []\n    created_examens_ids = []\n    try:\n        # Create two examens with known part_medecin and part_cabinet values for summation testing\n        for i in range(2):\n            examen_payload = {\n                \"name\": f\"Test Examen {i+1}\",\n                \"price\": 200 + i*100,  # arbitrary price\n                \"part_medecin\": 50 + i*10,  # doctor share\n                \"part_cabinet\": 30 + i*15,  # clinic share\n                \"category\": \"Radiology\",\n                \"code\": f\"EXAM{i+1}CODE\"\n            }\n            # Endpoint to create examen assumed /admin/examens POST for creation\n            create_examen_url = f\"{BASE_URL}/admin/examens\"\n            resp = session.post(create_examen_url, json=examen_payload, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code == 201, f\"Failed to create examen {i+1}: {resp.text}\"\n            examen_created = resp.json()\n            examen_id = examen_created.get(\"id\")\n            assert examen_id is not None, \"Created examen missing ID\"\n            created_examens_ids.append(examen_id)\n            examens_data.append({\n                \"examen_id\": examen_id,\n                \"quantity\": 2  # arbitrary quantity to test summing logic\n            })\n\n        # Step 2: Create caisse transaction with multiple examens\n        caisse_payload = {\n            \"medecin_id\": 1,\n            \"patient_id\": 1,\n            \"examens_data\": examens_data,\n            \"total\": 0,\n            \"mode_paiement_id\": 1\n        }\n        create_caisse_url = f\"{BASE_URL}/admin/caisses\"\n        resp = session.post(create_caisse_url, json=caisse_payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Failed to create caisse transaction: {resp.text}\"\n        caisse_created = resp.json()\n        caisse_id = caisse_created.get(\"id\")\n        assert caisse_id is not None, \"Created caisse transaction missing ID\"\n\n        # Step 3: Validate sums of part_medecin and part_clinique in response\n        expected_part_medecin = 0\n        expected_part_clinique = 0\n\n        # Fetch each examen details to get part_medecin and part_cabinet\n        for examen_entry in examens_data:\n            examen_id = examen_entry[\"examen_id\"]\n            qty = examen_entry[\"quantity\"]\n            examen_detail_url = f\"{BASE_URL}/admin/examens/{examen_id}\"\n            resp_examen = session.get(examen_detail_url, headers=headers, timeout=TIMEOUT)\n            assert resp_examen.status_code == 200, f\"Failed to fetch examen {examen_id} details: {resp_examen.text}\"\n            examen_detail = resp_examen.json()\n            part_medecin = examen_detail.get(\"part_medecin\", 0)\n            part_cabinet = examen_detail.get(\"part_cabinet\", 0)\n            expected_part_medecin += part_medecin * qty\n            expected_part_clinique += part_cabinet * qty\n\n        actual_part_medecin = caisse_created.get(\"part_medecin\")\n        actual_part_clinique = caisse_created.get(\"part_clinique\")\n\n        assert actual_part_medecin is not None, \"Caisse response missing part_medecin\"\n        assert actual_part_clinique is not None, \"Caisse response missing part_clinique\"\n\n        assert abs(actual_part_medecin - expected_part_medecin) < 0.01, \\\n            f\"part_medecin mismatch: expected {expected_part_medecin}, got {actual_part_medecin}\"\n        assert abs(actual_part_clinique - expected_part_clinique) < 0.01, \\\n            f\"part_clinique mismatch: expected {expected_part_clinique}, got {actual_part_clinique}\"\n\n    finally:\n        # Cleanup: delete caisse transaction and created examens\n        if 'caisse_id' in locals():\n            delete_caisse_url = f\"{BASE_URL}/admin/caisses/{caisse_id}\"\n            session.delete(delete_caisse_url, headers=headers, timeout=TIMEOUT)\n\n        for examen_id in created_examens_ids:\n            delete_examen_url = f\"{BASE_URL}/admin/examens/{examen_id}\"\n            session.delete(delete_examen_url, headers=headers, timeout=TIMEOUT)\n\ntest_verify_multiple_examens_in_caisse()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 117, in <module>\n  File \"<string>\", line 33, in test_verify_multiple_examens_in_caisse\nAssertionError: Login failed with status code 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.550Z",
    "modified": "2025-12-02T12:48:10.326Z"
  },
  {
    "projectId": "323a054b-1fb8-4a04-aef3-c1db1f2f31df",
    "testId": "c70368c8-c284-4fd7-93b5-03b5919bf350",
    "userId": "b4f8a4d8-9021-7004-78ff-426f6f28c79e",
    "title": "TC018-verify_caisse_pdf_export",
    "description": "Test PDF export functionality for caisse transactions (/caisses/{caisse}/exportPdf) and verify it includes all financial details including parts mÃ©decin and clinique.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:8000\"\nAUTH = HTTPBasicAuth(\"abdoullah@gmail.com\", \"12345678\")\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/pdf\"\n}\n\ndef test_verify_caisse_pdf_export():\n    caisse_id = None\n    created_caisse_id = None\n\n    # Step 1: Create a caisse transaction to have a valid resource for PDF export test\n    caisse_create_url = f\"{BASE_URL}/superadmin/caisses\"\n    caisse_data = {\n        # Minimal valid caisse creation data for financial transaction\n        \"description\": \"Test transaction for PDF export\",\n        \"montant\": 150.00,\n        \"mode_paiement\": \"espÃ¨ces\",\n        \"examen_ids\": [],  # Assuming empty list or valid exam IDs if required\n        \"date\": \"2025-11-19\",\n        # Add additional required fields here as per API schema if necessary\n    }\n\n    # Create a new caisse entry\n    try:\n        response_create = requests.post(\n            caisse_create_url,\n            auth=AUTH,\n            json=caisse_data,\n            timeout=TIMEOUT\n        )\n        assert response_create.status_code == 201, f\"Unexpected status code on caisse creation: {response_create.status_code}\"\n        created_caisse = response_create.json()\n        created_caisse_id = created_caisse.get(\"id\")\n        assert created_caisse_id is not None, \"Missing caisse ID in creation response\"\n\n        # Step 2: Export the PDF for the created caisse\n        pdf_export_url = f\"{BASE_URL}/caisses/{created_caisse_id}/exportPdf\"\n        response_pdf = requests.get(\n            pdf_export_url,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert response_pdf.status_code == 200, f\"PDF export failed with status {response_pdf.status_code}\"\n        content_type = response_pdf.headers.get(\"Content-Type\", \"\")\n        assert content_type == \"application/pdf\", f\"Expected PDF Content-Type but got {content_type}\"\n\n        pdf_content = response_pdf.content\n        assert len(pdf_content) > 1000, \"PDF content is unexpectedly small, may be invalid or empty\"\n\n        # Optional: Check for presence of key financial strings inside the PDF bytes decoded to text (may require pdf parsing lib)\n        # Since no library usage specified other than requests, apply basic bytes assert for presence of expected sections.\n        # We check raw PDF content for key byte strings for parts medecin and clinique (ASCII-only versions).\n        assert b\"partie medecin\" in pdf_content or b\"part_medecin\" in pdf_content or b\"medecin\" in pdf_content, \\\n            \"PDF does not contain medecin share information.\"\n        assert b\"partie clinique\" in pdf_content or b\"part_clinique\" in pdf_content or b\"clinique\" in pdf_content, \\\n            \"PDF does not contain clinique share information.\"\n        assert b\"recette\" in pdf_content or b\"total\" in pdf_content or b\"montant\" in pdf_content, \\\n            \"PDF does not contain financial totals or recette information.\"\n\n    finally:\n        # Cleanup: Delete the created caisse to maintain test environment\n        if created_caisse_id:\n            delete_url = f\"{BASE_URL}/superadmin/caisses/{created_caisse_id}\"\n            try:\n                response_delete = requests.delete(delete_url, auth=AUTH, timeout=TIMEOUT)\n                assert response_delete.status_code in (200, 204), f\"Failed to delete test caisse with status {response_delete.status_code}\"\n            except Exception:\n                pass\n\n\ntest_verify_caisse_pdf_export()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 76, in <module>\n  File \"<string>\", line 35, in test_verify_caisse_pdf_export\nAssertionError: Unexpected status code on caisse creation: 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-02T12:43:50.556Z",
    "modified": "2025-12-02T12:47:46.656Z"
  }
]
